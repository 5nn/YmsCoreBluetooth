<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">

	<title>Tutorial Document</title>

	<link rel="stylesheet" href="../../css/style.css">
	<meta name="viewport" content="initial-scale=1, maximum-scale=1.4">
	<meta name="generator" content="appledoc 2.2.1 (build 1334)">
</head>
<body class="appledoc">
	<header>
		<div class="container" class="hide-in-xcode">
			
			<h1 id="library-title">
				<a href="../../index.html">YmsCoreBluetooth Framework + Deanna </a>
			</h1>

			<p id="developer-home">
				<a href="../../index.html">Yummy Melon Software LLC</a>
			</p>
			
		</div>
	</header>

	<aside>
		<div class="container">
			<nav>
				<ul id="header-buttons" role="toolbar">
					<li><a href="../../index.html">Home</a></li>
				</ul>
			</nav>
		</div>
	</aside>

	<article>
		<div id="overview-contents" class="container">
			<div id="content">
				<main role="main">
					<h1 class="title">Tutorial Document</h1>

					<p><link rel="stylesheet" type="text/css" href="css/book.css" /></p>

<h1>YmsCoreBluetooth <a href="Tutorial.html">Tutorial</a></h1>

<p><strong>YmsCoreBluetooth</strong> is a framework for building Bluetooth LE capability to an iOS app. It extends the CoreBluetooth framework by implementing functionality to manage BLE peripherals, their services, and the characteristics of those services.</p>

<p>The communication patterns used by <strong>YmsCoreBluetooth</strong> are as follows:</p>

<ul>
<li><p>Notifications are handled by implementing a handler method.</p></li>
<li><p>Read/Write requests are handled using callback functions implemented as ObjectiveC blocks.</p></li>
</ul>


<p>This tutorial will describe how to build a Bluetooth LE peripheral driver based on YmsCoreBluetooth.</p>

<h1>Building a <em>SensorTag</em> Peripheral</h1>

<p>Shown below is a partial file hierarchy of <em>Deanna</em> to help illustrate the organization and construction of TI SensorTag peripheral using the <strong>YmsCoreBluetooth</strong> framework. There are two directories of interest:</p>

<ul>
<li><code>YmsCoreBluetooth/</code> which contains all files for this framework</li>
<li><code>Deanna/Services/</code> which contains an implementation of the <em>SensorTag</em> peripheral</li>
</ul>


<p><img src="images/ymscb_project_hierarchy.jpg" alt="YMSCB File Hierarchy" /></p>

<p>With the above figure, let&rsquo;s walk through building a <em>SensorTag</em> peripheral.</p>

<h2>Subclass <a href="../../Classes/YMSCBCentralManager.html">YMSCBCentralManager</a> to make <a href="../../Classes/DEACentralManager.html">DEACentralManager</a></h2>

<p>The class <a href="../../Classes/DEACentralManager.html">DEACentralManager</a> in <code>Deanna/Services/</code>DEACentralManager<code>.[hm]</code> is an application service to manage all known peripherals as defined by you the implementer. In this case we&rsquo;re only concerning ourselves with <em>SensorTag</em> peripherals.
It is typically implemented as a singleton instance and contains the following method implementations:</p>

<ul>
<li><code>initSharedServiceWithDelegate:</code></li>
<li><code>sharedService</code></li>
<li><code>startScan</code></li>
<li><code>handleFoundPeripheral</code></li>
<li><code>managerPoweredOnHandler</code></li>
</ul>


<p>The <code>initSharedServiceWithDelegate:</code> method is a singleton constructor for DEACentralManager. In this implementation, the property <a href="../../Classes/YMSCBCentralManager.html#//api/name/knownPeripheralNames">[YMSCBCentralManager knownPeripheralNames]</a> is set using <a href="../../Classes/YMSCBCentralManager.html#//api/name/initWithKnownPeripheralNames:queue:useStoredPeripherals:delegate:">[YMSCBCentralManager initWithKnownPeripheralNames:queue:useStoredPeripherals:delegate:]</a> to help identify and filter the peripherals you care to communicate with.</p>

<pre><code>+ (DEACentralManager *)initSharedServiceWithDelegate:(id)delegate {
    if (sharedCentralManager == nil) {
        dispatch_queue_t queue = dispatch_queue_create("com.yummymelon.deanna", 0);

        NSArray *nameList = @[@"TI BLE Sensor Tag", @"SensorTag"];
        sharedCentralManager = [[super allocWithZone:NULL] initWithKnownPeripheralNames:nameList
                                                                                  queue:queue
                                                                   useStoredPeripherals:YES
                                                                               delegate:delegate];
    }
    return sharedCentralManager;

}

+ (DEACentralManager *)sharedService {
    if (sharedCentralManager == nil) {
        NSLog(@"ERROR: must call initSharedServiceWithDelegate: first.");
    }
    return sharedCentralManager;
}
</code></pre>

<p>The <code>startScan</code> method lets you define how to go about scanning for peripherals. Within its implementation should be a call to <code>scanForPeripheralsWithServices:options:withBlock:</code> to tell the <code>CBCentralManager</code> property <code>manager</code> to start scanning.</p>

<pre><code>- (void)startScan {
    NSDictionary *options = @{ CBCentralManagerScanOptionAllowDuplicatesKey: @NO };

    __weak DEACentralManager *this = self;
    [self scanForPeripheralsWithServices:nil
                                 options:options
                               withBlock:^(CBPeripheral *peripheral, NSDictionary *advertisementData, NSNumber *RSSI, NSError *error) {
                                   if (error) {
                                       NSLog(@"Something bad happened with scanForPeripheralWithServices:options:withBlock:");
                                       return;
                                   }

                                   NSLog(@"DISCOVERED: %@, %@, %@ db", peripheral, peripheral.name, RSSI);
                                   [this handleFoundPeripheral:peripheral];
                               }];
}
</code></pre>

<p>Note that a weak pointer named <code>this</code> is set to <code>self</code>. This is done to handle retain issues with referencing self within an ObjectiveC block.</p>

<p>The callback block is executed upon a response from a BLE peripheral that is advertising. A discovered BLE peripheral will pass a pointer to itself (<code>peripheral</code>), advertisement data (<code>advertisementData</code>), its RSSI value (<code>RSSI</code>), and in the event of a failure, an error object (<code>error</code>) to the callback block. In this implementation, the execution of the callback block will call <code>handleFoundPeripheral:</code>. Note that the statements in <code>handleFoundPeripheral:</code> could just as easily be located within the block statement.</p>

<p>The <code>handleFoundPeripheral:</code> method defines what to do once you&rsquo;ve found a peripheral via scanning. In the case of a <em>SensorTag</em> it is to instantiate <a href="../../Classes/DEASensorTag.html"><code>DEASensorTag</code></a>, a subclass of <a href="../../Classes/YMSCBPeripheral.html"><code>YMSCBPeripheral</code></a>.</p>

<pre><code>- (void)handleFoundPeripheral:(CBPeripheral *)peripheral {
    YMSCBPeripheral *yp = [self findPeripheral:peripheral];

    if (yp == nil) {
        BOOL isUnknownPeripheral = YES;
        for (NSString *pname in self.knownPeripheralNames) {
            if ([pname isEqualToString:peripheral.name]) {
                DEASensorTag *sensorTag = [[DEASensorTag alloc] initWithPeripheral:peripheral
                                                                           central:self
                                                                            baseHi:kSensorTag_BASE_ADDRESS_HI
                                                                            baseLo:kSensorTag_BASE_ADDRESS_LO];

                [self.ymsPeripherals addObject:sensorTag];
                isUnknownPeripheral = NO;
                break;

            }

        }

        if (isUnknownPeripheral) {
            //TODO: Handle unknown peripheral
            yp = [[YMSCBPeripheral alloc] initWithPeripheral:peripheral central:self baseHi:0 baseLo:0];
            [self.ymsPeripherals addObject:yp];
        }
    }

}
</code></pre>

<p>An alternate implementation of <code>startScan</code> without using a block callback is to use <code>scanForPeripheralsWithServices:options:</code>. In this case, you then <em>must</em> implement <code>handleFoundPeripheral:</code> to handle the discovered peripheral.</p>

<p>A common task is to define program behavior upon a change in the state of <code>CBCentralManager</code>. This is accomplished by implementing the methods which are named after their respective states:</p>

<ul>
<li><code>managerPoweredOnHandler</code></li>
<li><code>managerUnknownHandler</code></li>
<li><code>managerPoweredOffHandler</code></li>
<li><code>managerResettingHandler</code></li>
<li><code>managerUnauthorizedHandler</code></li>
<li><code>managerUnsupportedHandler</code></li>
</ul>


<p>For our purpose, we are interested on retrivieving previously discovered peripherals whose UUIDs have been persisted from a previous run of the app upon <code>CBCentralManager</code> being powered on:</p>

<pre><code>- (void)managerPoweredOnHandler {
    if (self.useStoredPeripherals) {
        NSArray *identifiers = [YMSCBStoredPeripherals genIdentifiers];
        [self retrievePeripheralsWithIdentifiers:identifiers];
    }
}
</code></pre>

<h2>Subclass <a href="../../Classes/YMSCBPeripheral.html">YMSCBPeripheral</a> to make <a href="../../Classes/DEASensorTag.html">DEASensorTag</a></h2>

<p>The class implementation of <code>DEASensorTag</code> in <code>Deanna/Services/SensorTag/DEASensorTag.[hm]</code> is where the top-level behavior of the <em>SensorTag</em> peripheral is captured. Two methods are implemented:</p>

<ul>
<li><code>initWithPeripheral:central:baseHi:baseLo:</code> - the constructor for <a href="../../Classes/DEASensorTag.html">DEASensorTag</a></li>
<li><code>connect</code> - the method to initiate a connection request for the peripheral.</li>
</ul>


<p>The class constructor for <code>DEASensorTag</code> is responsible for instantiating subclasses of <code>YMSCBService</code> to capture the behavior of the different BLE services offered by the <em>SensorTag</em>. The source for this constructor, <code>initWithPeripheral:central:baseHi:baseLo:</code> is shown below:</p>

<pre><code>- (instancetype)initWithPeripheral:(CBPeripheral *)peripheral
                           central:(YMSCBCentralManager *)owner
                            baseHi:(int64_t)hi
                            baseLo:(int64_t)lo {

    self = [super initWithPeripheral:peripheral central:owner baseHi:hi baseLo:lo];

    if (self) {
        DEATemperatureService *ts = [[DEATemperatureService alloc] initWithName:@"temperature" parent:self baseHi:hi baseLo:lo serviceOffset:kSensorTag_TEMPERATURE_SERVICE];
        DEAAccelerometerService *as = [[DEAAccelerometerService alloc] initWithName:@"accelerometer" parent:self baseHi:hi baseLo:lo  serviceOffset:kSensorTag_ACCELEROMETER_SERVICE];
        DEASimpleKeysService *sks = [[DEASimpleKeysService alloc] initWithName:@"simplekeys" parent:self baseHi:0 baseLo:0  serviceOffset:kSensorTag_SIMPLEKEYS_SERVICE];
        DEAHumidityService *hs = [[DEAHumidityService alloc] initWithName:@"humidity" parent:self baseHi:hi baseLo:lo  serviceOffset:kSensorTag_HUMIDITY_SERVICE];
        DEABarometerService *bs = [[DEABarometerService alloc] initWithName:@"barometer" parent:self baseHi:hi baseLo:lo  serviceOffset:kSensorTag_BAROMETER_SERVICE];
        DEAGyroscopeService *gs = [[DEAGyroscopeService alloc] initWithName:@"gyroscope" parent:self baseHi:hi baseLo:lo  serviceOffset:kSensorTag_GYROSCOPE_SERVICE];
        DEAMagnetometerService *ms = [[DEAMagnetometerService alloc] initWithName:@"magnetometer" parent:self baseHi:hi baseLo:lo  serviceOffset:kSensorTag_MAGNETOMETER_SERVICE];
        DEADeviceInfoService *ds = [[DEADeviceInfoService alloc] initWithName:@"devinfo" parent:self baseHi:0 baseLo:0  serviceOffset:kSensorTag_DEVINFO_SERV_UUID];

        self.serviceDict = @{@"temperature": ts,
                             @"accelerometer": as,
                             @"simplekeys": sks,
                             @"humidity": hs,
                             @"magnetometer": ms,
                             @"gyroscope": gs,
                             @"barometer": bs,
                             @"devinfo": ds};
    }
    return self;

}
</code></pre>

<p>In this implementation, the following BLE services of the <em>SensorTag</em> are supported:</p>

<ul>
<li>Temperature Service - <a href="../../Classes/DEATemperatureService.html">DEATemperatureService</a></li>
<li>Accelerometer Service - <a href="../../Classes/DEAAccelerometerService.html">DEAAccelerometerService</a></li>
<li>Simple Keys Service - <a href="../../Classes/DEASimpleKeysService.html">DEASimpleKeysService</a></li>
<li>Humidity Service - <a href="../../Classes/DEAHumidityService.html">DEAHumidityService</a></li>
<li>Barometer Service - <a href="../../Classes/DEABarometerService.html">DEABarometerService</a></li>
<li>Gyroscope Service - <a href="../../Classes/DEAGyroscopeService.html">DEAGyroscopeService</a></li>
<li>Magnetometer Service - <a href="../../Classes/DEAMagnetometerService.html">DEAMagnetometerService</a></li>
<li>Device Information Service - <a href="../../Classes/DEADeviceInfoService.html">DEADeviceInfoService</a></li>
<li></li>
</ul>


<p>The instances of these classes are stored in the dictionary <a href="../../Classes/YMSCBPeripheral.html#//api/name/serviceDict">[YMSCBPeripheral serviceDict]</a> where their respective keys are human-readable strings.</p>

<p>The <code>connect</code> method implements all the desired behavior involved with connecting to a BLE peripheral. It is here where the utility of ObjectiveC blocks to handle response behavior becomes evident.</p>

<p>In the following implementation the following tasks are undertaken in sequential order:</p>

<ul>
<li>peripheral connection (<code>connectionWithOptions:withBlock:</code>)</li>
<li>discover services for that peripheral (<code>discoverServices:withBlock:</code>)</li>
<li>discover charcteristics for each service (<code>discoverChararcteristics:withBlock:</code>)</li>
<li>discover descriptors for each characteristic (<code>discoverDescriptors:withBlock:</code>)</li>
</ul>


<p>Note that the tasks listed above are accomplished via a nested chain of callbacks.</p>

<pre><code>- (void)connect {
    // Watchdog aware method
    [self resetWatchdog];

    [self connectWithOptions:nil withBlock:^(YMSCBPeripheral *yp, NSError *error) {
        if (error) {
            return;
        }

        [yp discoverServices:[yp services] withBlock:^(NSArray *yservices, NSError *error) {
            if (error) {
                return;
            }

            for (YMSCBService *service in yservices) {
                if ([service.name isEqualToString:@"simplekeys"]) {
                    __weak DEASimpleKeysService *thisService = (DEASimpleKeysService *)service;
                    [service discoverCharacteristics:[service characteristics] withBlock:^(NSDictionary *chDict, NSError *error) {
                        [thisService turnOn];
                    }];

                } else if ([service.name isEqualToString:@"devinfo"]) {
                    __weak DEADeviceInfoService *thisService = (DEADeviceInfoService *)service;
                    [service discoverCharacteristics:[service characteristics] withBlock:^(NSDictionary *chDict, NSError *error) {
                        [thisService readDeviceInfo];
                    }];

                } else {
                    __weak DEABaseService *thisService = (DEABaseService *)service;
                    [service discoverCharacteristics:[service characteristics] withBlock:^(NSDictionary *chDict, NSError *error) {
                        for (NSString *key in chDict) {
                            YMSCBCharacteristic *ct = chDict[key];
                            //NSLog(@"%@ %@ %@", ct, ct.cbCharacteristic, ct.uuid);

                            [ct discoverDescriptorsWithBlock:^(NSArray *ydescriptors, NSError *error) {
                                if (error) {
                                    return;
                                }
                                for (YMSCBDescriptor *yd in ydescriptors) {
                                    NSLog(@"Descriptor: %@ %@ %@", thisService.name, yd.UUID, yd.cbDescriptor);
                                }
                            }];
                        }
                    }];
                }
            }
        }];
    }];
}
</code></pre>

<h2>Define BLE services of this peripheral.</h2>

<p>The BLE services of a peripheral are described by using subclasses of <a href="../../Classes/YMSCBService.html">YMSCBService</a>. For the <em>SensorTag</em>, all but the device information service (<a href="../../Classes/DEADeviceInfoService.html">DEADeviceInfoService</a>) are subclassed from <a href="../../Classes/DEABaseService.html">DEABaseService</a> which has support for common configuration and turn on/off behavior.</p>

<p>This subclass is responsible for implementing:</p>

<ul>
<li>Properties that are specific to the bluetooth service.</li>
<li>The class constructor [YMSCBService initWithName:parent:baseHi:baseLo:], defining the BLE characteristics with subclasses of YMSCBCharacteristic via <a href="../../Classes/YMSCBService.html#//api/name/addCharacteristic:withOffset:">[YMSCBService addCharacteristic:withOffset:]</a>.</li>
<li><code>notifyCharacteristicHandler</code> to handle responses for characteristics whose notifications have been turned on.</li>
<li>Any processing logic germane to the BLE service (e.g. temperature conversion, data correction/smoothing, etc.).</li>
<li>Specific read/write transaction sequences germane to the BLE service.</li>
</ul>


<p>Shown below is the implementation for <code>DEAAccelerometerService</code>.</p>

<pre><code>#import "DEAAccelerometerService.h"
#import "YMSCBCharacteristic.h"

float calcAccel(int16_t rawV) {
    float v;
    v = ((float)rawV + 1.0) / (256.0/4.0);
    return v;
}

@implementation DEAAccelerometerService

- (instancetype)initWithName:(NSString *)oName
                      parent:(YMSCBPeripheral *)pObj
                      baseHi:(int64_t)hi
                      baseLo:(int64_t)lo
               serviceOffset:(int)serviceOffset {

    self = [super initWithName:oName
                        parent:pObj
                        baseHi:hi
                        baseLo:lo
                 serviceOffset:serviceOffset];

    if (self) {
        [self addCharacteristic:@"data" withOffset:kSensorTag_ACCELEROMETER_DATA];
        [self addCharacteristic:@"config" withOffset:kSensorTag_ACCELEROMETER_CONFIG];
        [self addCharacteristic:@"period" withOffset:kSensorTag_ACCELEROMETER_PERIOD];
    }
    return self;
}

- (void)notifyCharacteristicHandler:(YMSCBCharacteristic *)yc error:(NSError *)error {

    if (error) {
        return;
    }

    if ([yc.name isEqualToString:@"data"]) {
        NSData *data = yc.cbCharacteristic.value;

        char val[data.length];
        [data getBytes:&amp;val length:data.length];

        int16_t xx = val[0];
        int16_t yy = val[1];
        int16_t zz = val[2];

        __weak DEAAccelerometerService *this = self;
        _YMS_PERFORM_ON_MAIN_THREAD(^{
            this.x = [NSNumber numberWithFloat:calcAccel(xx)];
            this.y = [NSNumber numberWithFloat:calcAccel(yy)];
            this.z = [NSNumber numberWithFloat:calcAccel(zz)];
        });
    }
}

- (void)configPeriod:(uint8_t)value {

    YMSCBCharacteristic *periodCt = self.characteristicDict[@"period"];
    __weak DEAAccelerometerService *this = self;
    [periodCt writeByte:value withBlock:^(NSError *error) {
        //NSLog(@"Set period to: %x", value);
        this.period = @(value);
    }];
}

- (void)readPeriod {
    YMSCBCharacteristic *periodCt = self.characteristicDict[@"period"];

    __weak DEAAccelerometerService *this = self;

    [periodCt readValueWithBlock:^(NSData *data, NSError *error) {
        char val[data.length];
        [data getBytes:&amp;val length:data.length];

        int16_t periodValue = val[0];

        _YMS_PERFORM_ON_MAIN_THREAD(^{
            this.period = @(periodValue);
        });
    }];
}

@end
</code></pre>

<p>The class constructor <code>initWithName:parent:baseHi:baseLo:serviceOffset:</code> defines three BLE characteristics using <a href="../../Classes/YMSCBService.html#//api/name/addCharacteristic:withOffset:">[YMSCBService addCharacteristic:withOffset:]</a> which we can reference with the following four strings: (&ldquo;data&rdquo;, &ldquo;config&rdquo;, &ldquo;period&rdquo;).</p>

<p>When the service is turned on using the method <a href="../../Classes/DEABaseService.html#//api/name/turnOn">[DEABaseService turnOn]</a>, notifications for the &ldquo;data&rdquo; characteristic are turned on. Handling notification events sent from the <em>SensorTag</em> are handled by <code>notifyCharacteristicHandler</code>. The acceleration measurements are stored as <code>NSNumber</code> properties <code>x</code>, <code>y</code>, <code>z</code>. These properties can then be Key-Value Observed (KVO) by the application, typically to be displayed in user interface.</p>

<p><strong>Important</strong>: To let the UI components in the main thread know via KVO that a property has changed, you must update that property on the main thread. A convenience macro <code>_YMS_PERFORM_ON_MAIN_THREAD</code> which uses the GCD call <code>dispatch_async()</code> does just that:</p>

<pre><code>#define _YMS_PERFORM_ON_MAIN_THREAD(block) dispatch_async(dispatch_get_main_queue(), block);
</code></pre>

<h1>Comments</h1>

<p>This document can always be improved. Please submit any comments or corrections about this document to the <a href="https://github.com/kickingvegas/YmsCoreBluetooth/issues?state=open">issue tracker</a> for <strong>YmsCoreBluetooth</strong>.</p>

<p>Thank you for using <strong>YmsCoreBluetooth</strong>!</p>

					<footer>
						<div class="footer-copyright">
							
							<p class="copyright">Copyright &copy; 2015 Yummy Melon Software LLC. All rights reserved. Updated: 2015-10-17</p>
							
							
							<p class="generator">Generated by <a href="http://appledoc.gentlebytes.com">appledoc 2.2.1 (build 1334)</a>.</p>
							
						</div>
					</footer>
				</main>
			</div>
		</div>
	</article>

	<script src="../../js/script.js"></script>
</body>
</html>